---
title: "R Notebook"
output: html_document
---

```{r echo=FALSE}
knitr::opts_chunk$set(eval=evaluate, cache=cache.me)
```

Phytoplankton sampling event data obtained from CEDR ([Download Monitoring Event]) is imported.
```{r}
wq.df <- data.table::fread(file.path(project.dir, "data/water_quality/cedr_wq.csv"),
                            data.table = FALSE,
                           na.strings = c(""))
```

Convert the sample date (`sampledate`) to class date.
```{r}
wq.df <- wq.df %>% 
  mutate(sampledate = as.Date(sampledate))
```

Extract the salinity zone (`salzone`) found in `bay.df`.
```{r}
bay.salzone <- bay.df %>% 
  select(station, sampledate, salzone) %>% 
  distinct()
```

Append the salinity zone (`salzone`) to `wq.df`.
```{r}
wq.df <- inner_join(wq.df, bay.salzone, by = c("station", "sampledate"))
```

## Processing

The phytoplankton indices only utilize measures of Dissolved Organic Carbon (DOC), chlorophyll a, and pheophytin. Therefore, only these water quality parameters are retained.
```{r}
wq.df <- wq.df %>% 
  filter(is.na(problem)) %>% 
  unite(parameter, layer, parameter) %>% 
  filter(str_detect(parameter, "chla|pheo|doc"))
```

The stations with water quality data are plotted using `leaflet`, to provide a visual reference and check of the data.
```{r}
stations.df <- wq.df %>% 
  dplyr::select(station, agency, source, latitude, longitude) %>% 
  distinct() %>% 
  mutate(longitude = jitter(longitude, amount = 0.0005),
         latitude = jitter(latitude, amount = 0.0005))

leaflet(stations.df) %>% 
    addProviderTiles(providers$CartoDB.Positron,
                   options = leaflet::tileOptions(minZoom = 7, maxZoom = 18)) %>% 
  addCircleMarkers( ~longitude, ~latitude,
                    stroke = FALSE,
                    fillOpacity = 0.5,
                    popup = paste("Station:", stations.df$station, "<br/>",
                                  "Agency:", stations.df$agency, "<br/>",
                                  "Source:", stations.df$source, "<br/>",
                                  "Latitude:", stations.df$latitude, "<br/>",
                                  "Longitude:", stations.df$longitude)) %>% 
   leaflet::setMaxBounds(lng1 = -78, lat1 = 36, lng2 = -75, lat2 = 40.5) %>% 
  leaflet::setView(-76.4, lat = 38, zoom = 7) 
```

The following chunks of code summarize the water quality data according the the Methods section in [@BuchananPhytoplanktonreferencecommunities2005] (page 139). The water quality data is divided into separate data frames, manipulated accordingly, and then appended back together.

Surface chlorophyll a ("s_chla") is extracted as a separate data frame and the summarized to represent the mean value for each station, replicate type, and date.
```{r}
wq.s_chla <- wq.df %>% 
  select(station, samplereplicatetype, sampledate, parameter, measurevalue) %>% 
  filter(parameter == "s_chla") %>% 
  distinct() %>% 
  select(-samplereplicatetype) %>% 
  group_by_at(vars(-measurevalue)) %>% 
  summarize(measurevalue = mean(measurevalue, is.na = TRUE)) %>% 
  ungroup()
```

If the upper pycnocline depth is not specified, then the mean for each parameter (i.e. chlorophyll a, pheophytin, DOC) is found using samples from the entire water column [@BuchananPhytoplanktonreferencecommunities2005] (page 139).
```{r}
wq.sub.tf <- wq.df %>% 
  filter(salzone == "f") %>% 
  #filter(is.na(upperpycnocline)) %>% 
  #filter(startsWith(station, "f")) %>% 
  select(station, samplereplicatetype, sampledate, parameter, measurevalue) %>% 
  filter(grepl("chla|pheo|doc", parameter)) %>% 
  distinct() %>% 
  mutate(parameter = case_when(
    grepl("chla", parameter) ~ "chla",
    grepl("pheo", parameter) ~ "pheo",
    grepl("doc", parameter) ~ "doc",
    TRUE ~ "ERROR"
  )) %>% 
  select(-samplereplicatetype) %>% 
  group_by_at(vars(-measurevalue)) %>% 
  summarize(measurevalue = mean(measurevalue)) %>% 
  ungroup()
```

If the upper pycnocline depth is specified, then the mean for each parameter (i.e. chlorophyll a, pheophytin, DOC) is found using samples specified as above the pycnocline ("ap") and surface ("s") [@BuchananPhytoplanktonreferencecommunities2005] (page 139).
```{r}
wq.sub.pycno <- wq.df %>% 
  filter(salzone != "f",
    #!is.na(upperpycnocline),
         grepl("ap_|s_", parameter)) %>% 
  #filter(!startsWith(station, "f")) %>% 
  select(station, samplereplicatetype, sampledate, parameter, measurevalue) %>% 
  distinct() %>% 
  mutate(parameter = case_when(
    parameter %in% c("ap_chla", "s_chla") ~ "chla",
    parameter %in% c("ap_pheo", "s_pheo") ~ "pheo",
    parameter %in% c("ap_doc", "s_doc") ~ "doc",
    TRUE ~ "ERROR"
  )) %>% 
  select(-samplereplicatetype) %>% 
  group_by_at(vars(-measurevalue)) %>% 
  summarize(measurevalue = mean(measurevalue)) %>% 
  ungroup()
```

The separate water quality data frames are appended together.
```{r}
wq.sub <- bind_rows(wq.s_chla, wq.sub.tf, wq.sub.pycno) %>% 
  rename(date = sampledate)
```

## 3-Day Window

In some case the water quality data was not collected on the same day as the phytoplankton data. To obtain more phytoplankton sampling events with associated water quality data, [@LacouturePhytoplanktonindexbiotic2006] used water quality data collected within ± 3 days of the phytoplankton.

`bay.df` is subset to only represent unique combinations of `station` and `sampledate`.
```{r}
bay.sub <- bay.df %>% 
  select(station, sampledate) %>% 
  distinct() %>% 
  mutate(lower_date = sampledate - lubridate::days(3),
         upper_date = sampledate + lubridate::days(3))
```

The process to identify water quality dates within the ± 3 day window of the phytoplankton sampling date can be lengthy. The `parallel` package is used again to speed up the process.
```{r message=FALSE}
library(parallel)
n.cores <- detectCores() - 1
cl <- makeCluster(n.cores)
clusterExport(cl = cl, varlist = c("wq.sub", "bay.sub"))
clusterEvalQ(cl, c(library(dplyr))) %>% invisible()
```

For each station and sample date combination (each row) in `bay.sub`, all of the `wq.sub` samples, from the same station, within a ± 3 day window are found. If there are multiple `wq.sub` samples within the ± 3 day window, then the sample collected closest to the phytoplankton data is retained. There is a possibility that water quality samples could be collected at equal intervals before and after phytoplankton sampling. For example, water quality samples could have been collected one day before and one day after phytoplankton sampling. In those instances the sample collected prior to the phytoplankton sampling is retained.
```{r}
env.df <- parLapply(cl, 1:nrow(bay.sub), function(row.i) {

  sub.df <- slice(bay.sub, row.i)
  #----------------------------------------------------------------------------
  sub.env <- wq.sub %>% 
    filter(station == sub.df$station,
           date >= sub.df$lower_date,
           date <= sub.df$upper_date)
  #----------------------------------------------------------------------------
  if (nrow(sub.env) == 0) return(data.frame(
    station = NA,
    date = NA,
    parameter = NA,
    measurevalue = NA
  ))
  #----------------------------------------------------------------------------
  final.df <- sub.env %>% 
    mutate(date_diff = date - sub.df$sampledate,
           abs_date_diff = abs(date_diff),
           sampledate = sub.df$sampledate) %>% 
    filter(abs_date_diff == min(abs_date_diff))
  #----------------------------------------------------------------------------
  if (nrow(final.df) > 1) {
    final.df <- final.df %>% 
      filter(date == min(date))
  }
  #----------------------------------------------------------------------------
  return(final.df)
}) %>% 
  bind_rows() %>% 
  filter(!is.na(station))

stopCluster(cl)
#closeAllConnections()
```

The water quality data is transformed from a long data format to a wide data format.
```{r}
env.wide <- env.df %>% 
  spread(parameter, measurevalue)
```

`s_shla` and `pheo` are given more descriptive names, `surface_chla` and `pheophytin`, respectively. Additionally, the script ensures that `surface_chla`, `pheophytin`, and `doc` are all numeric values. Finally, the columns are subset to prepare to join with `bay.df`.
```{r}
env.wide <- env.wide %>% 
  mutate(
    surface_chla = if_else(!is.na(s_chla), s_chla, as.numeric(NA)),
    pheophytin = if_else(!is.na(pheo), pheo, as.numeric(NA)),
    doc = if_else(!is.na(doc), doc, as.numeric(NA))
    ) %>% 
  select(station, sampledate, surface_chla, chla, pheophytin, doc)
```

Join `bay.df` with `env.wide` to combine phytoplankton count data with water quality data.
```{r}
bay.df <- left_join(bay.df, env.wide, by = c("station", "sampledate"))
```

Remove objects that are no longer necessary.
```{r}
#rm(env.df, env.wide, wq.df, wq.sub, bay.sub)
```

