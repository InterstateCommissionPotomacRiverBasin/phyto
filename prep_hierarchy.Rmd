---
title: "Hierarchy"
output: html_notebook
---
```{r echo=FALSE}
knitr::opts_chunk$set(eval=evaluate)
```


Load the __tidyverse__ for data manipulation.
```{r, message=FALSE}
library(tidyverse)
```

### ITIS

Connect to ITIS PostgreSQL database.
```{r}
source("conn_postgres.R")
#on.exit(dbDisconnect(conn), add = TRUE)
```

Import taxa hierarchy data from the database.
```{r}
hier.df <- tbl(conn, "hierarchy") %>% 
  data.frame() %>% 
  clean_up()
```


Import synonym data from the database. This information is used to identify 
and convert invalid tsn's to accepted tsn's.
```{r}
syn.df <- tbl(conn, "synonym_links") %>% 
  select(1:2) %>% 
  data.frame() %>% 
  clean_up()
```

Import NODC data from the database. Several taxa in the database were assigned 
a NODC code but not a tsn. Many of the NODC codes can be correctly linked to 
an accepted tsn using this table. Leading and trailing white space is removed 
from the `nodc_id` column. Additionally, if a leading zero is present in the 
`nodc_id` column, then it is removed to be consistent with the NODC code 
format found in the CBP data.
```{r}
nodc.df <- tbl(conn, "nodc_ids") %>% 
  select(nodc_id, tsn) %>% 
  data.frame() %>% 
  clean_up() %>% 
  mutate(nodc_id = gsub("^[0]", "", nodc_id)) %>% 
  rename(nodccode = nodc_id,
         nodc_tsn = tsn)
```

The "kingdom" data is download  and joined to the 
"taxon_unit_types" data below.
```{r}
kingdoms <- tbl(conn, "kingdoms") %>% 
  select(1:2) %>% 
  data.frame() %>% 
  clean_up()
```

_Section_ and _Subsection_ represent different taxonomic ranks for
the Animailia and Plantae kingdoms. Therefore, the appropriate 
kingdom suffix was added to the end of each of the ranks.
```{r}
taxa.types <- tbl(conn, "taxon_unit_types") %>% 
  select(kingdom_id, rank_id, rank_name) %>% 
  distinct() %>% 
  arrange(rank_id) %>% 
  data.frame() %>% 
  clean_up() %>% 
  left_join(kingdoms, by = "kingdom_id") %>% 
  mutate(rank_name = case_when(
    rank_id == 124 ~ "section_animalia",
    rank_id == 126 ~ "subsection_animalia",
    rank_id == 200 ~ "section_plantae",
    rank_id == 210 ~ "subsection_plantae",
    TRUE ~ rank_name
  ))
```

The "taxonomic_units" ITIS table provides all of the TSNs and there 
associated Kingdom, rank IDs, and Latin names. I have found that white 
space, " ", frequently causes issues with joining or filtering. Therefore, 
`trimws()` is used to remove leading and trailing white space from 
the `complete_name` column. Subsequently, any remaining white space 
is replaced with an underscore, "_".
```{r}
taxa.units <- tbl(conn, "taxonomic_units") %>% 
  select(tsn, name_usage, kingdom_id, rank_id, complete_name) %>% 
  distinct() %>% 
  data.frame() %>% 
  clean_up()
```


The `taxa.units` and `taxa.types` data frames are joined together by 
the `kingdom_id` and `rank_id` columns to replace the `rank_id` in 
`taxa.units` with the associated `rank_name` from `taxa.types.
```{r}
taxa.df <- left_join(taxa.units, taxa.types, by = c("kingdom_id", "rank_id")) %>% 
  select(-kingdom_id, -rank_id, -kingdom_name)
```

Remove all unnecessary objects from the environment.
```{r}
rm(conn, kingdoms, taxa.types, taxa.units)
```

### Taxonomic Data

CBP taxonomic count data is imported and `Methods` other than "PH", 
__PH__-ytoplankton methods, 
are excluded from the data frame. Additionally, taxa identified as 
"Micro-phytoflagellates", "Green cells", or "Blue green sphere" were 
excluded from this analysis because these taxa could not be identified 
to a discernible taxon, and therefore are not useful.

All column names are converted to lowercase to make them easier to type. 
Several of the NODC codes 
contain character values that are not present in the ITIS NODC codes. 
These character values were appended on to valid NODC codes to identify 
taxa (e.g., species or subspecies) that are not in the NODC database. 
To obtain as much taxonomic hierarchy data as possible for these taxa, the 
character values are removed and, when applicable, the numeric values are 
matched to valid NODC codes and subsequently ITIS tsn values. The numeric 
values are extracted from the `nodccode` column and any leading 
zeros are removed. 
```{r}
bay.df <- data.table::fread("data/LivingResourcesReportedHUC8.csv",
                            data.table = FALSE) %>% 
  clean_up() %>% 
  # Removes methods with prefix "BE" (Tidal Benthic Taxa Enumeration) or blanks.
  filter(grepl("ph", method),
         !latinname %in% c("micro-phytoflagellates", "green_cells",
                           "blue_green_sphere", "epiphytic_flagellates")) %>% 
  mutate(nodc_num = gsub("[^0-9]", "", nodccode),
         nodc_num = gsub("^[0]", "", nodc_num))
```

The ITIS NODC data frame is joined with the taxonomic counts. 
If the reported TSN equals zero and the `nodc_tsn` is not `NA`, 
then the `nodc_tsn` is used to fill in the `final_tsn` column; 
otherwise, the reported `tsn` is used as the `final_tsn`. 
NODC codes "7030526" and "7403100180" were not found in the ITIS 
NODC codes. These NODC codes were specifically assigned the appropriate
`final_tsn`.
```{r}
bay.df <- bay.df %>% 
  left_join(nodc.df, by = c("nodc_num" = "nodccode")) %>% 
  mutate(final_tsn = if_else(
    !is.na(nodc_tsn) & tsn == 0,
    nodc_tsn,
    tsn),
    final_tsn = case_when(
      nodc_num == "7030526" ~ as.integer(3649),
      nodc_num == "7403100180" ~ as.integer(5204),
      TRUE ~ final_tsn
    ))
```

As stated above, many NODC codes contained characters to identify 
a taxa to a higher resolution than what is available in the NODC 
database. More than 70 taxa were not found in the ITIS database. 
Eight of these taxa appear to no longer be valid taxonomic names or 
were due to data entry errors. 

The ninth taxon, Didymocystis, was 
assigned the wrong TSN. ITIS contains the genus Didymocystis under 
the phylum platyhelminthes. This Didymocystis should be 
classified under the division Chlorophyta; however, this genus 
does not exist in the ITIS database. The TSN for the family 
Didymocystis belongs to, Oocystaceae, was assigned and used to 
obtain most of the taxonomic information for this taxon. Similarly,
the tenth taxon, Lauterborniella elegantissima, is the name for an 
insect of the family Chironomidae or algae of the family Scenedesmaceae. 
We assume that reported taxon was algae but, again, there is no ITIS 
TSN for this taxon. The TSN for the Scenedesmaceae was used to obtain the 
majority of the taxonomic information. The genus and species names are 
appended later in the script. The `final_tsn` is updated to link 
to the appropriate taxonomic name in ITIS.
```{r}
bay.df <- bay.df %>% 
  mutate(
    final_tsn = case_when(
      latinname == "navicula_notablis" ~ as.integer(4327),
      latinname == "pleurosigma_macrum" ~ as.integer(4650),
      latinname == "pleurosigma_obscurum" ~ as.integer(591383),
      latinname == "polykrikos_hartmannii" ~ as.integer(331299),
      latinname == "protoperidinium_aciculiderum" ~ as.integer(10329),
      latinname == "protoperidinium_paulseni" ~ as.integer(3568),
      latinname == "scrippsiella_favionese" ~ as.integer(10537),
      latinname == "tetrastrum_caudatum" ~ as.integer(5691),
      latinname == "didymocystis" ~ as.integer(5810),
      latinname == "lauterborniella_elegantissima" ~ as.integer(6097),
      TRUE ~ final_tsn
    )
  )
```

The ITIS synonym data is joined with the taxonomic counts to 
identify TSN's that are no longer valid and to assign the valid TSN.
```{r}
bay.df <- bay.df %>% 
  left_join(syn.df, by = c("final_tsn" = "tsn")) %>% 
  mutate(
    final_tsn = if_else(
      is.na(tsn_accepted),
      final_tsn,
      tsn_accepted
    ))
```

#### Taxonomic Hierarchy
In the ITIS database the taxonomic hierarchy is listed as a single string 
of TSNs separated by hyphens ("-"). To utilize the taxonomic information 
the string needs to separated into individual TSNs. The number of TSNs in the 
strings is inconsistent, and therefore the string that contains the most hyphens 
is used to identify the number of columns necessary to split all of the strings.
`stringer::str_count()` is used to count the number of hyphens in each string, which 
is identified in the column `hyphen_count`. The max `hyphen_count` plus one is used 
to specify the necessary number of columns. `tidyr::separate()` is used to split 
the string by the hyphen into multiple columns. Most strings will not fill all of 
the columns. The remaining columns are filled with `NA`. The split TSNs are then 
transformed to a long data format using `tidyr::gather()` and the `NAs` are removed.
```{r warning=FALSE}
hier.long <- hier.df %>% 
  filter(tsn %in% unique(bay.df$final_tsn)) %>% 
  mutate(hyphen_count = stringr::str_count(hierarchy_string, '-')) %>% 
  separate(hierarchy_string,
           into = paste("tsn", seq(1:(max(.$hyphen_count) + 1)), sep = "_"),
           extra = "drop") %>% 
  select(-parent_tsn, -level, -childrencount, -hyphen_count) %>% 
  rename(final_tsn = tsn) %>% 
  gather(col_name, tsn, -final_tsn, na.rm = TRUE) %>% 
  select(-col_name) %>% 
  mutate(tsn = as.numeric(tsn))
```

`hier.vec` is a vector of all of the taxonomic ranks in ITIS sorted in the 
correct order. This vector will be used to sort the the succeeding data 
frame into the appropriate order.
```{r}
hier.vec <- c("kingdom", "subkingdom", "infrakingdom", 
              "superdivision", "division", "subdivision", "infradivision",
              "superphylum", "phylum", "subphylum", "infraphylum", 
              "superclass", "class", "subclass", "infraclass", 
              "superorder", "order", "suborder", "infraorder", 
              "section_animalia", "subsection_animalia", 
              "superfamily", "family", "subfamily", 
              "tribe", "subtribe", 
              "genus", "subgenus", 
              "section_botany", "subsection_botany",
              "species", "subspecies", 
              "variety", "form", "race", "stirp", "morph", "aberration", "unspecified")
```

`hier.long` only contains a list of TSNs, which are not informative. The data is 
joined with the `taxa.df` data frame by the `tsn` column. `taxa.df` provides the 
name associated with each TSN. Using `tidyr::complete()`, the data frame is expanded 
so that each taxon rank present in `hier.vec` is represented for each taxon in this 
data frame. Missing ranks will receive an `NA` in the `complete_name` column. 
The `complete_name` column is duplicated and `tidyr::fill()` is used to fill all of the 
`NA`'s with the proceeding non-`NA` value. A new column is created, `final_id`, 
using `dplyr::mutate()` and `dplyr::last()` to extract the last taxonomic name for 
each unique `final_tsn`. The data frame is then turned into a wide format  
to provide a more intuitive view of the data. Each row represents information associated 
with a single taxon and each column provides taxonomic names when available.
```{r}
hier.wide <- left_join(hier.long, taxa.df,  by = "tsn") %>% 
  select(-tsn, -name_usage) %>% 
  complete(final_tsn, nesting(rank_name)) %>% 
  mutate(rank_name = factor(rank_name, levels = hier.vec),
         taxa_fill = complete_name) %>% 
  arrange(final_tsn, rank_name) %>% 
  fill(taxa_fill) %>% 
  group_by(final_tsn) %>% 
  mutate(final_id = last(taxa_fill)) %>% 
  select(-taxa_fill) %>% 
  spread(rank_name, complete_name) 
```

The taxonomic counts are joined with the taxonomic hierarchy data by
the `final_tsn` columns.
```{r}
bay.df <- left_join(bay.df, hier.wide, by = "final_tsn")
```

Some taxa require specific attention before they can be finalized.
```{r}
bay.df <- bay.df %>% 
  mutate(genus = case_when(latinname == "didymocystis" ~ "didymocystis",
                           latinname == "Lauterborniella_elegantissima" ~ "lauterborniella",
                           TRUE ~ genus),
         species = if_else(latinname == "lauterborniella_elegantissima", 
                           "lauterborniella_elegantissima",
                           species))
```

Remove all unnecessary objects from the environment.
```{r}
rm(hier.df, hier.long, hier.wide, nodc.df, syn.df, taxa.df, hier.vec)
```

